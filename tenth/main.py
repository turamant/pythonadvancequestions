"""10. Интроспекция и рефлексия

Проблема: Вы хотите понять концепции интроспекции(самоанализа) и
рефлексии(отражение) в программировании и определить, поддерживает ли Python эти функции.

Решение: Интроспекция – это способность языка программирования исследовать,
анализировать и манипулировать своими собственными структурами и объектами.
Python решительно поддерживает интроспекцию, что означает, что вы можете
проверять и манипулировать различными аспектами объектов, классов и модулей во время исполнения.
Вот несколько способов, которыми Python поддерживает Интроспекцию:
Получение типа объекта. Вы можете использовать функцию type(), чтобы определить тип объекта.
Получение атрибутов объекта. Функция dir() позволяет получить
атрибуты и методы объекта.
Проверка документации: Вы можете получить доступ к строкам документации,
используя .__doc__ атрибут.
Получение базовых классов объекта. Атрибут .__bases__ помогает проверить
базовые классы класса.
Импорт динамических модулей: Python позволяет импортировать динамические модули с помощью
importlib или __import__.
Динамическое создание функций/классов. Вы можете динамически создавать функции и
классы, использующие type() и методы метапрограммирования.
Проверка атрибутов. Функция hasattr() проверяет, имеет ли объект
конкретный атрибут или метод.
Проверка возможности вызова: функция callable() проверяет, может ли объект быть вызван как
функция."""


import importlib

# Пример класса для исследования
class ExampleClass:
    """Это пример класса для демонстрации интроспекции."""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def add(self):
        """Возвращает сумму x и y."""
        return self.x + self.y
    
    def multiply(self):
        """Возвращает произведение x и y."""
        return self.x * self.y

# Создаем экземпляр класса
obj = ExampleClass(2, 3)

# Получение типа объекта
print("Тип объекта:", type(obj))

# Получение атрибутов объекта
print("Атрибуты и методы объекта:", dir(obj))

# Проверка документации
print("Документация класса:", ExampleClass.__doc__)
print("Документация метода add:", obj.add.__doc__)

# Получение базовых классов объекта
print("Базовые классы исключения object:",  obj.__class__.__bases__)

# Импорт динамического модуля
math_module = importlib.import_module('math')
print("Динамически импортированного модуля math:", math_module)

# Динамическое создание функции
def dynamic_function(self):
    """Это динамически созданная функция."""
    return f"Dynamic function result: {self.x * self.y}"

# Динамическое создание класса с добавлением динамически созданной функции
DynamicClass = type('DynamicClass', (ExampleClass,), {'dynamic_function': dynamic_function})

# Создаем экземпляр динамического класса
dynamic_obj = DynamicClass(4, 5)
print("Результат динамически созданной функции:", dynamic_obj.dynamic_function())
print("Документация динамически созданной функции:", dynamic_obj.dynamic_function.__doc__)

# Проверка атрибутов
if hasattr(dynamic_obj, 'multiply'):
    print("Метод multiply существует")

# Проверка возможности вызова 
if callable(dynamic_obj.dynamic_function):
    print("Метод dynamic_function может быть вызван")

if __name__ == "__main__":
    # Простая проверка методов класса ExampleClass
    print("Сумма x и y:", obj.add())
    print("Произведение x и y:", obj.multiply())

    # Проверка методов динамически созданного класса DynamicClass
    print("Сумма x и y в DynamicClass:", dynamic_obj.add())
    print("Произведение x и y в DynamicClass:", dynamic_obj.multiply())

